import fs from 'fs';
import globby from 'globby';
import { blueBright, bold, green, yellow, magenta } from 'colorette';

const rules = [
  {
    name: 'Website',
    types: ['js', 'css', 'html'],
  },
  {
    name: 'Assets',
    types: ['png', 'jpg', 'svg'],
  },
  {
    name: 'Other',
    types: ['*'],
  },
];

/** Format bytes to a human readable size */
function formatBytesHuman(bytes) {
  const list = ['b', 'Kb', 'Mb', 'Gb', 'Tb'];
  for (const it of list) {
    if (bytes < 1000) {
      return `${bytes}${it}`;
    } else {
      bytes = (bytes / 1000).toFixed(2);
    }
  }
  return `${bytes}Tb`;
}

/** Return the file extension from a file */
function extractExtension(path) {
  var dotIndex = path.lastIndexOf('.');
  return dotIndex == -1 ? null : path.substring(dotIndex + 1);
}

/** Check if rule apply on extension */
function rulesMatchExtension(rule, extension) {
  for (const type of rule.types) {
    if (type === extension || type === '*') {
      return true;
    }
  }
  return false;
}

/** Generate a dummy service worker for development hot reload */
function generateDevSWDataJS() {
  return `/* ----- This file is automatically generated, it is not intended for manual editing ----- */

// Skip installation
self.addEventListener('install', event => event.waitUntil(self.skipWaiting()));

// Delete previous caches
self.addEventListener('activate', event => {
  event.waitUntil(
    caches.keys().then(cacheNames => {
      if (cacheNames.length >= 0) {
        // Remove previous caches
        Promise.all(
          cacheNames.map(name => {
            return caches.delete(name);
          })
        );
      }
    })
  );
});

// Bypass to network
self.addEventListener('fetch', event =>
  event.respondWith(fetch(event.request))
);
`;
}

/** Generate a service worker file */
function generateSWDataJS(date, files) {
  let buffer = '';
  for (const file of files) {
    buffer += `  \"${file}\",\n`;
  }
  buffer;
  return `/* ----- This file is automatically generated, it is not intended for manual editing ----- */
// The date of the generation. Used to invalidate previous caches
const date = \"${date}\";
// An array of paths to prefetch
const filesToCache = [
${buffer}];
// The name of the current cache
const cacheName = 'cache-' + date;
// Install service worker: create and initialize the cache
self.addEventListener('install', event => {
  event.waitUntil(
    caches
      .open(cacheName)
      .then(cache => {
        // Pre cache files
        return cache.addAll(filesToCache);
      })
  );
});

// Skip waiting when requested
self.addEventListener('message',event => {
  if (event.data === "skip") {
    self.skipWaiting();
  }
})

// Activate service worker: delete previous caches
self.addEventListener('activate', event => {
  event.waitUntil(
    caches.keys().then(cacheNames => {
      Promise.all(
        cacheNames.map(name => {
          if (name !== cacheName) {
            return caches.delete(name);
          }
        })
      )
    })
  );
});

// Intercept fetch event
self.addEventListener('fetch', event => {
  // Apply a cache first strategy
  event.respondWith(
    caches.open(cacheName).then(cache => {
      return cache.match(event.request).then(response => {
        if (response) {
          return response;
        }
        return fetch(event.request.clone()).then(response => {
          // Cache font files at runtime
          if (
            response.status < 400 &&
            response.headers.get('content-type') &&
            response.headers.get('content-type').match(/^font\\//)
          ) {
            cache.put(event.request, response.clone());
          }
          return response;
        });
      });
    })
  );
});
`;
}

export default function serviceWorker(options = {}) {
  let {
    dir = './public',
    swName = 'sw.js',
    dev = false,
    manualPaths = [],
    verbose = true,
    showRulesPaths = false,
    showPrefetchPaths = false,
  } = options;

  return {
    name: 'serviceWorker',
    async writeBundle() {
      if (dev) {
        // Create dev service worker file and exit
        const swSrc = `${dir}/${swName}`;
        fs.writeFileSync(swSrc, generateDevSWDataJS());
        console.log(blueBright(bold('Service Worker:') + 'skipped (dev)'));
        return;
      }

      // Get the relative path of all files in dir
      let paths = (await globby(dir + '/**/*')).map(path =>
        path.substring(dir.length)
      );

      // Apply rules
      const rulesResult = rules.map(rule => ({
        ...rule,
        paths: [],
        sizeSum: 0,
      }));
      for (const path of paths) {
        const size = fs.statSync(dir + path).size;
        const extension = extractExtension(path);
        for (const rule of rulesResult) {
          if (rulesMatchExtension(rule, extension)) {
            rule.paths.push(path);
            rule.sizeSum += size;
            break;
          }
        }
      }
      // Add manual path and src path
      if (paths.indexOf(`/${swName}`) == -1) {
        paths.push(`/${swName}`);
      }
      paths = ['/'].concat(paths, manualPaths);

      // Generate service worker file
      const date = Date.now();
      const swData = generateSWDataJS(date, paths);

      // Write service worker file
      const swSrc = `${dir}/${swName}`;
      fs.writeFileSync(swSrc, swData);

      // Output generation result
      if (verbose) {
        console.log(blueBright(bold('Service Worker:')));
        for (const rule of rulesResult) {
          if (rule.paths.length > 0) {
            console.log(
              magenta(rule.name) +
                ' - ' +
                green(bold(rule.paths.length) + ' files') +
                ' - ' +
                yellow(bold(formatBytesHuman(rule.sizeSum)))
            );
            if (showRulesPaths) {
              for (const path of rule.paths) {
                console.log(' ' + path);
              }
            }
          }
        }
        console.log(green(bold(paths.length) + ' prefetched path in total'));
        if (showPrefetchPaths) {
          for (const path of paths) {
            console.log(' ' + path);
          }
        }
      }
    },
  };
}