import fs from 'fs';
import globby from 'globby';
import { blueBright, bold, green, yellow, magenta } from 'colorette';

/** Format bytes to a human readable size */
function formatBytesHuman(bytes) {
  const list = ['b', 'Kb', 'Mb', 'Gb', 'Tb'];
  for (const it of list) {
    if (bytes < 1000) {
      return `${bytes}${it}`;
    } else {
      bytes = (bytes / 1000).toFixed(2);
    }
  }
  return `${bytes}Tb`;
}

/** Extract the file extension from a file path */
function extractExtension(path) {
  var dotIndex = path.lastIndexOf('.');
  return dotIndex == -1 ? null : path.substring(dotIndex + 1);
}

/** Check a given extension is supported */
function matchExtension(supportedExtension, extension) {
  return (
    supportedExtension.indexOf(extension) != -1 ||
    supportedExtension.indexOf('*') != -1
  );
}

/** Generate a dummy service worker for development hot reload */
function generateDevSWDataJS() {
  return `/* ----- This file is automatically generated, it is not intended for manual editing ----- */

// Skip installation
self.addEventListener('install', event => event.waitUntil(self.skipWaiting()));

// Delete previous caches
self.addEventListener('activate', event => {
  event.waitUntil(
    caches.keys().then(cacheNames => {
      if (cacheNames.length >= 0) {
        // Remove previous caches
        Promise.all(
          cacheNames.map(name => {
            return caches.delete(name);
          })
        );
      }
    })
  );
});

// Bypass to network
self.addEventListener('fetch', event =>
  event.respondWith(fetch(event.request))
);
`;
}

/** Generate a service worker file */
function generateSWDataJS(date, files, runtimeTypes) {
  let fileBuffer = '';
  for (const file of files) {
    fileBuffer += `  \"${file}\",\n`;
  }
  let typeBuffer = '';
  for (const type of runtimeTypes) {
    typeBuffer += `  ${type},\n`;
  }
  return `/* ----- This file is automatically generated, it is not intended for manual editing ----- */
// The date of the generation. Used to invalidate previous caches
const date = \"${date}\";
// An array of paths to prefetch
const filesToCache = [
${fileBuffer}];
// An array of mime type to cache at runtime
const runtimeTypes = [
${typeBuffer}];
// The name of the current cache
const cacheName = 'cache-' + date;
// Install service worker: create and initialize the cache
self.addEventListener('install', event => {
  event.waitUntil(
    caches
      .open(cacheName)
      .then(cache => {
        // Pre cache files
        return cache.addAll(filesToCache);
      })
  );
});

// Skip waiting when requested
self.addEventListener('message',event => {
  if (event.data === "skip") {
    self.skipWaiting();
  }
})

// Activate service worker: delete previous caches
self.addEventListener('activate', event => {
  event.waitUntil(
    caches.keys().then(cacheNames => {
      Promise.all(
        cacheNames.map(name => {
          if (name !== cacheName) {
            return caches.delete(name);
          }
        })
      )
    })
  );
});

// Check content-type against every runtime types
function typeToBeCached(type) {
  for (const regex of runtimeTypes) {
    if (type.match(regex)) {
      return true;
    }
  }
  return false;
}

// Intercept fetch event
self.addEventListener('fetch', event => {
  // Apply a cache first strategy
  event.respondWith(
    caches.open(cacheName).then(cache => {
      return cache.match(event.request).then(response => {
        if (response) {
          return response;
        }
        return fetch(event.request.clone()).then(response => {
          // Cache font files at runtime
          if (
            response.status < 400 &&
            response.headers.get('content-type') &&
            typeToBeCached(response.headers.get('content-type'))
          ) {
            cache.put(event.request, response.clone());
          }
          return response;
        });
      });
    })
  );
});

`;
}

export default function serviceWorker(options = {}) {
  let {
    dir = './public',
    swName = 'sw.js',
    dev = false,
    manualPaths = [],
    prefetchTypes = ['js', 'css', 'html', 'svg'],
    runtimeTypes = [/^font\//],
    verbose = true,
    showPrefetchedPaths = false,
    showIgnoredPaths = false,
  } = options;

  return {
    name: 'serviceWorker',
    async writeBundle() {
      // Get service worker path from config
      const swPath = `${dir}/${swName}`;
      const swFetchPath = `/${swName}`;

      if (dev) {
        // Create dev service worker file and exit
        fs.writeFileSync(swSrc, generateDevSWDataJS());
        if (verbose) {
          console.log(
            blueBright(bold('Service Worker:') + ' skipped (dev mode)')
          );
        }
        return;
      }

      // Get the relative path of all files in dir
      const paths = (await globby(dir + '/**/*'))
        .map(path => path.substring(dir.length))
        .filter(path => path != swFetchPath);

      // Filtering result
      const ignoredPaths = [];
      let cachedPaths = [];
      let sizeSum = 0;

      // Filter precached files
      for (const path of paths) {
        const size = fs.statSync(dir + path).size;
        const extension = extractExtension(path);

        if (matchExtension(prefetchTypes, extension)) {
          cachedPaths.push(path);
          sizeSum += size;
        } else {
          ignoredPaths.push(path);
        }
      }

      // Aggregate final paths
      const finalPaths = ['/', swFetchPath].concat(cachedPaths, manualPaths);

      // Generate service worker file
      const date = Date.now();
      const swData = generateSWDataJS(date, finalPaths, runtimeTypes);

      // Write service worker file
      fs.writeFileSync(swPath, swData);

      // Output generation result
      if (verbose) {
        console.log(blueBright(bold('Service Worker:')));
        console.log(
          magenta('Prefetched files') +
            ' - ' +
            green(bold(cachedPaths.length) + ' files') +
            ' - ' +
            yellow(bold(formatBytesHuman(sizeSum)))
        );
        if (showIgnoredPaths) {
          console.log(
            yellow(bold(ignoredPaths.length) + ' paths where ignored')
          );
          for (const path of ignoredPaths) {
            console.log(' ' + path);
          }
        }
        if (showPrefetchedPaths) {
          console.log(
            green(bold(finalPaths.length) + ' prefetched path in total')
          );
          for (const path of finalPaths) {
            console.log(' ' + path);
          }
        }
      }
    },
  };
}
